/**
 * Streaming Types
 *
 * Platform-independent types for streaming model responses and engine events.
 * Used by both backend (@agentick/core) and frontend (@agentick/client).
 *
 * ## Event Architecture
 *
 * - **ModelStreamEvent**: Model output events (content, reasoning, messages, tool calls)
 * - **OrchestrationStreamEvent**: Orchestration events (execution lifecycle, ticks, tool results)
 * - **ResultStreamEvent**: Final execution result
 * - **StreamEvent**: Combined union of all streamable events
 *
 * ## Event Pattern
 *
 * For streamable content, events follow the pattern:
 * ```
 * [thing]_start → [thing]_delta (0..n) → [thing]_end → [thing] (fully formed)
 * ```
 *
 * This allows consumers to choose granularity:
 * - Streaming UI: Listen for `*_delta` events
 * - Simple consumption: Listen for `content`, `reasoning`, `message`, `tool_call`
 */

import type { ContentBlock } from "./blocks";
import type { BlockType } from "./block-types";
import type { Message } from "./messages";
import type { UsageStats } from "./models";
import type { ToolExecutor } from "./tools";
import type { SessionResultPayload } from "./protocol";

// ============================================================================
// Content Metadata Types
// ============================================================================

/**
 * Citation - normalized reference to source material.
 *
 * Adapters map provider-specific citation formats to this normalized structure.
 * - Anthropic: citations with source info
 * - Google: grounding sources/chunks
 * - OpenAI: annotations with file citations
 */
export interface ContentCitation {
  /** Citation text shown in the response */
  text: string;
  /** Source URL if available */
  url?: string;
  /** Source title/name */
  title?: string;
  /** Start index in the content this citation applies to */
  startIndex?: number;
  /** End index in the content this citation applies to */
  endIndex?: number;
}

/**
 * Annotation - model-provided note about the content.
 *
 * Adapters map provider-specific annotation formats to this normalized structure.
 */
export interface ContentAnnotation {
  /** Annotation type (e.g., "file_citation", "note", "highlight") */
  type: string;
  /** Annotation content/text */
  text: string;
  /** Start index in the content */
  startIndex?: number;
  /** End index in the content */
  endIndex?: number;
  /** Additional annotation-specific data */
  data?: Record<string, unknown>;
}

/**
 * Normalized content metadata.
 *
 * Adapters populate these fields when provider data maps to them.
 * Provider-specific data that doesn't fit these fields goes in `extensions`.
 *
 * Note: Artifacts are NOT part of content metadata. Artifacts are created
 * via tool calls and managed as session state parallel to the timeline.
 * See plans/agentic/artifacts.md for the artifact pattern.
 */
export interface ContentMetadata {
  /** Citations/sources referenced by the model */
  citations?: ContentCitation[];

  /** Model-provided annotations on the content */
  annotations?: ContentAnnotation[];

  /** Programming language (for code blocks) */
  language?: string;

  /** MIME type hint */
  mimeType?: string;

  /** Provider-specific extensions (not normalized) */
  extensions?: Record<string, unknown>;
}

// ============================================================================
// Stop Reason
// ============================================================================

/**
 * Stop reason enumeration.
 * Defines why model generation stopped.
 *
 * Key distinction:
 * - NATURAL_COMPLETION: Model decided to stop (maps to provider's end_turn, stop, etc.)
 * - EXPLICIT_COMPLETION: Engine/runtime requested the stop (max ticks, abort, etc.)
 *
 * Usage by layer:
 * - ModelStreamEvent (message_end): Model's stop reason (TOOL_USE, MAX_TOKENS, NATURAL_COMPLETION)
 * - OrchestrationStreamEvent (execution): May be EXPLICIT_COMPLETION if engine stopped early
 */
export enum StopReason {
  MAX_TOKENS = "max_tokens",
  STOP_SEQUENCE = "stop_sequence",
  CONTENT_FILTER = "content_filter",
  TOOL_USE = "tool_use",
  FUNCTION_CALL = "function_call",
  UNSPECIFIED = "unspecified",
  OTHER = "other",
  STOP = "stop",
  PAUSED = "paused",
  FORMAT_ERROR = "format_error",
  EMPTY_RESPONSE = "empty_response",
  NO_CONTENT = "no_content",
  EXPLICIT_COMPLETION = "explicit_completion",
  NATURAL_COMPLETION = "natural_completion",
  ERROR = "error",
}

// ============================================================================
// Base Event Structure
// ============================================================================

/**
 * Base fields shared by all stream events.
 */
export interface StreamEventBase {
  /** Normalized event ID (generated by entity-ids if provider doesn't provide one) */
  id: string;

  /**
   * Monotonically increasing sequence number within the session.
   *
   * Enables:
   * - Durable streams (reconnection, replay)
   * - Gap detection (missing events)
   * - Ordering guarantees
   * - Deduplication
   *
   * Assigned by the session when emitting events. Starts at 1.
   */
  sequence: number;

  /** Tick number (default 1 for direct model calls without engine) */
  tick: number;

  /** ISO 8601 timestamp when event was created/emitted */
  timestamp: string;

  /** Original provider event/chunk for pass-through (debugging, provider-specific features) */
  raw?: unknown;

  /** Session ID (if available) */
  /** Available on all events emitted from within a session */
  sessionId?: string;
}

// ============================================================================
// ModelStreamEvent (Model Output)
// ============================================================================

/**
 * Content block events (text, images, etc.)
 *
 * Metadata is available on content_start, content_end, and content events.
 * It is NOT included on content_delta events to avoid noise during streaming.
 */
export type ContentStartEvent = {
  type: "content_start";
  blockType: BlockType;
  blockIndex: number;
  /** Content metadata (citations, annotations, language hints) */
  metadata?: ContentMetadata;
} & StreamEventBase;

export type ContentDeltaEvent = {
  type: "content_delta";
  blockType: BlockType;
  blockIndex: number;
  delta: string;
  // Note: No metadata on deltas - too noisy. Captured in start/end events.
} & StreamEventBase;

export type ContentEndEvent = {
  type: "content_end";
  blockType: BlockType;
  blockIndex: number;
  /** Content metadata (citations, annotations, language hints) */
  metadata?: ContentMetadata;
} & StreamEventBase;

export type ContentEvent = {
  type: "content";
  blockIndex: number;
  content: ContentBlock;
  /** Content metadata (citations, annotations, language hints) */
  metadata?: ContentMetadata;
  startedAt: string;
  completedAt: string;
} & StreamEventBase;

/**
 * Reasoning/thinking events (separate for easy filtering)
 *
 * Metadata is available on reasoning_start, reasoning_end, and reasoning events.
 * Reasoning can have citations when the model references sources during thinking.
 */
export type ReasoningStartEvent = {
  type: "reasoning_start";
  blockIndex: number;
  /** Reasoning metadata (citations, annotations) */
  metadata?: ContentMetadata;
} & StreamEventBase;

export type ReasoningDeltaEvent = {
  type: "reasoning_delta";
  blockIndex: number;
  delta: string;
  // Note: No metadata on deltas - too noisy. Captured in start/end events.
} & StreamEventBase;

export type ReasoningEndEvent = {
  type: "reasoning_end";
  blockIndex: number;
  /** Reasoning metadata (citations, annotations) */
  metadata?: ContentMetadata;
} & StreamEventBase;

export type ReasoningEvent = {
  type: "reasoning";
  blockIndex: number;
  reasoning: string;
  /** Reasoning metadata (citations, annotations) */
  metadata?: ContentMetadata;
  startedAt: string;
  completedAt: string;
} & StreamEventBase;

/**
 * Message lifecycle events
 */
export type MessageStartEvent = {
  type: "message_start";
  role: "assistant";
  model?: string;
} & StreamEventBase;

export type MessageEndEvent = {
  type: "message_end";
  stopReason: StopReason;
  usage?: UsageStats;
} & StreamEventBase;

export type MessageEvent = {
  type: "message";
  message: Message;
  stopReason: StopReason;
  usage?: UsageStats;
  model?: string;
  /** Raw provider response (e.g., AI SDK generateText result, OpenAI ChatCompletion) */
  raw?: unknown;
  startedAt: string;
  completedAt: string;
} & StreamEventBase;

/**
 * Tool call events (model requesting tool execution)
 */
export type ToolCallStartEvent = {
  type: "tool_call_start";
  callId: string;
  name: string;
  blockIndex: number;
} & StreamEventBase;

export type ToolCallDeltaEvent = {
  type: "tool_call_delta";
  callId: string;
  blockIndex: number;
  delta: string;
} & StreamEventBase;

export type ToolCallEndEvent = {
  type: "tool_call_end";
  callId: string;
  blockIndex: number;
} & StreamEventBase;

export type ToolCallEvent = {
  type: "tool_call";
  callId: string;
  blockIndex: number;
  name: string;
  input: Record<string, unknown>;
  startedAt: string;
  completedAt: string;
} & StreamEventBase;

/**
 * Error event
 */
export type StreamErrorEvent = {
  type: "error";
  error: {
    message: string;
    code?: string;
  };
} & StreamEventBase;

/**
 * Usage event - standalone usage update.
 *
 * Some providers (e.g., OpenAI with stream_options.include_usage) send usage
 * data in a separate chunk after the finish_reason chunk. This event captures
 * that usage without triggering another message_end.
 */
export type UsageEvent = {
  type: "usage";
  usage: {
    inputTokens: number;
    outputTokens: number;
    totalTokens: number;
  };
} & StreamEventBase;

/**
 * ModelStreamEvent - All model output events.
 *
 * Discriminated union of all events that come from model streaming.
 */
export type ModelStreamEvent =
  // Content blocks
  | ContentStartEvent
  | ContentDeltaEvent
  | ContentEndEvent
  | ContentEvent
  // Reasoning/thinking
  | ReasoningStartEvent
  | ReasoningDeltaEvent
  | ReasoningEndEvent
  | ReasoningEvent
  // Message lifecycle
  | MessageStartEvent
  | MessageEndEvent
  | MessageEvent
  // Tool calls
  | ToolCallStartEvent
  | ToolCallDeltaEvent
  | ToolCallEndEvent
  | ToolCallEvent
  // Usage (standalone, for providers that send it separately)
  | UsageEvent
  // Errors
  | StreamErrorEvent;

// ============================================================================
// OrchestrationStreamEvent (Orchestration)
// ============================================================================

/**
 * Execution lifecycle events
 *
 * Note: threadId and other app-specific identifiers are in metadata.
 * sessionId is kept top-level as it's universal for client connections.
 */
export type ExecutionStartEvent = {
  type: "execution_start";
  executionId: string;
  sessionId?: string;
  parentExecutionId?: string;
  rootExecutionId?: string;
  componentName?: string;
  /** User-provided metadata (includes threadId, userId, etc.) */
  metadata?: Record<string, unknown>;
} & StreamEventBase;

export type ExecutionEndEvent = {
  type: "execution_end";
  executionId: string;
  sessionId?: string;
  parentExecutionId?: string;
  rootExecutionId?: string;
  /** Why the execution stopped */
  stopReason?: StopReason | string;
  /** Whether execution was aborted */
  aborted?: boolean;
  output: unknown;
  /** User-provided metadata (includes threadId, userId, etc.) */
  metadata?: Record<string, unknown>;
} & StreamEventBase;

export type ExecutionEvent = {
  type: "execution";
  executionId: string;
  sessionId?: string;
  parentExecutionId?: string;
  rootExecutionId?: string;
  output: unknown;
  usage: UsageStats;
  stopReason: StopReason;
  /** User-provided metadata (includes threadId, userId, etc.) */
  metadata?: Record<string, unknown>;
  ticks: number;
  startedAt: string;
  completedAt: string;
} & StreamEventBase;

/**
 * Tick lifecycle events
 */
export type TickStartEvent = {
  type: "tick_start";
  tick: number;
  executionId?: string;
} & StreamEventBase;

export type TickEndEvent = {
  type: "tick_end";
  tick: number;
  executionId?: string;
  /** Whether execution should continue */
  shouldContinue?: boolean;
  usage?: UsageStats;
  /** New timeline entries added during this tick (for persistence) */
  response?: {
    newTimelineEntries?: unknown[];
  };
  /** Why the model stopped */
  stopReason?: StopReason | string;
  /** Model ID used for this tick */
  model?: string;
} & StreamEventBase;

export type TickEvent = {
  type: "tick";
  tick: number;
  usage: UsageStats;
  stopReason: StopReason;
  startedAt: string;
  completedAt: string;
} & StreamEventBase;

/**
 * Tool result event (unified - executedBy indicates source)
 */
export type ToolResultEvent = {
  type: "tool_result";
  callId: string;
  name: string;
  result: unknown;
  isError?: boolean;
  executedBy: ToolExecutor;
  startedAt: string;
  completedAt: string;
} & StreamEventBase;

/**
 * Tool confirmation events (for requiresConfirmation tools)
 */
export type ToolConfirmationRequiredEvent = {
  type: "tool_confirmation_required";
  callId: string;
  name: string;
  input: Record<string, unknown>;
  message: string;
} & StreamEventBase;

export type ToolConfirmationResultEvent = {
  type: "tool_confirmation_result";
  callId: string;
  confirmed: boolean;
  always?: boolean;
} & StreamEventBase;

/**
 * DevTools event: Compiled context (after JSX compilation, before model call)
 */
export type CompiledEvent = {
  type: "compiled";
  executionId?: string;
  /** System prompt / instructions */
  system?: string;
  /** Messages in the conversation */
  messages?: unknown[];
  /** Available tools */
  tools?: Array<{ name?: string; description?: string }>;
} & StreamEventBase;

/**
 * DevTools event: Model request (Agentick format input)
 */
export type ModelRequestEvent = {
  type: "model_request";
  executionId?: string;
  /** Model identifier */
  modelId?: string;
  /** The input sent to the model (Agentick format) */
  input: unknown;
} & StreamEventBase;

/**
 * DevTools event: Provider request (SDK-specific format)
 */
export type ProviderRequestEvent = {
  type: "provider_request";
  executionId?: string;
  /** Model identifier */
  modelId?: string;
  /** Provider name (e.g., "openai", "anthropic", "google") */
  provider?: string;
  /** The input sent to the provider SDK (provider-specific format) */
  providerInput: unknown;
} & StreamEventBase;

/**
 * DevTools event: Model response (pipeline visibility)
 */
export type ModelResponseEvent = {
  type: "model_response";
  executionId?: string;
  /** Provider output (raw SDK response, may be reconstructed for streaming) */
  providerOutput?: unknown;
  /** ModelOutput (normalized Agentick format) */
  modelOutput?: {
    model?: string;
    message?: unknown;
    usage?: UsageStats;
    stopReason?: string;
    toolCalls?: Array<{ id: string; name: string; input: unknown }>;
  };
  /** Engine state (how response is ingested into timeline) */
  engineState?: {
    newTimelineEntries?: unknown[];
    toolCalls?: unknown[];
    shouldStop?: boolean;
    stopReason?: unknown;
  };
} & StreamEventBase;

/**
 * Engine error event
 */
export type EngineErrorEvent = {
  type: "engine_error";
  error: {
    message: string;
    code?: string;
  };
} & StreamEventBase;

/**
 * Context update event - provides real-time context utilization info.
 *
 * Emitted after each tick with context window usage, model capabilities,
 * and cumulative token usage. Enables React UIs to show context utilization bars.
 */
export type ContextUpdateEvent = {
  type: "context_update";
  /** Model ID (e.g., "gpt-4o", "claude-3-5-sonnet-20241022") */
  modelId: string;
  /** Human-readable model name */
  modelName?: string;
  /** Provider name */
  provider?: string;
  /** Context window size in tokens */
  contextWindow?: number;
  /** Input tokens used this tick */
  inputTokens: number;
  /** Output tokens generated this tick */
  outputTokens: number;
  /** Total tokens this tick */
  totalTokens: number;
  /** Context utilization percentage (0-100) */
  utilization?: number;
  /** Max output tokens */
  maxOutputTokens?: number;
  /** Model capabilities */
  supportsVision?: boolean;
  supportsToolUse?: boolean;
  isReasoningModel?: boolean;
  /** Cumulative usage across all ticks in this execution */
  cumulativeUsage?: {
    inputTokens: number;
    outputTokens: number;
    totalTokens: number;
    ticks: number;
  };
} & StreamEventBase;

/**
 * Fork lifecycle events
 *
 * Fork creates parallel execution branches that race or vote.
 * Each branch runs as a separate execution - subscribe to those
 * executions directly if you need branch-level observability.
 */
export type ForkStartEvent = {
  type: "fork_start";
  /** Unique identifier for this fork operation */
  forkId: string;
  /** Parent execution that initiated the fork */
  parentExecutionId: string;
  /** Strategy for handling branch results */
  strategy: "race" | "vote" | "all";
  /** Identifiers for each branch (variant names or indices) */
  branches: string[];
  /** Number of parallel branches */
  branchCount: number;
  /** Input passed to the fork (shared across branches or per-branch) */
  input?: unknown;
} & StreamEventBase;

export type ForkEndEvent = {
  type: "fork_end";
  /** Unique identifier for this fork operation */
  forkId: string;
  /** Parent execution that initiated the fork */
  parentExecutionId: string;
  /** The winning/selected branch (for race/vote strategies) */
  selectedBranch?: string;
  /** Aggregated results from all branches */
  results: Record<string, unknown>;
  /** Token usage aggregated across all branches */
  usage?: UsageStats;
} & StreamEventBase;

/**
 * Spawn lifecycle events
 *
 * Spawn creates a child execution that runs independently.
 * Unlike Fork, Spawn doesn't race - it's for delegation.
 */
export type SpawnStartEvent = {
  type: "spawn_start";
  /** Unique identifier for this spawn operation */
  spawnId: string;
  /** Parent execution that initiated the spawn */
  parentExecutionId: string;
  /** Child execution ID */
  childExecutionId: string;
  /** Name of the spawned component/agent */
  componentName?: string;
  /** Optional label for this spawn */
  label?: string;
  /** Input passed to the spawned execution */
  input?: unknown;
} & StreamEventBase;

export type SpawnEndEvent = {
  type: "spawn_end";
  /** Unique identifier for this spawn operation */
  spawnId: string;
  /** Parent execution that initiated the spawn */
  parentExecutionId: string;
  /** Child execution ID */
  childExecutionId: string;
  /** Output from the spawned execution */
  output: unknown;
  /** Whether the spawn errored */
  isError?: boolean;
  /** Token usage from the spawned execution */
  usage?: UsageStats;
} & StreamEventBase;

/**
 * OrchestrationStreamEvent - All orchestration events.
 *
 * Discriminated union of all events from engine orchestration.
 */
export type OrchestrationStreamEvent =
  // Execution lifecycle
  | ExecutionStartEvent
  | ExecutionEndEvent
  | ExecutionEvent
  // Tick lifecycle
  | TickStartEvent
  | TickEndEvent
  | TickEvent
  // Tool execution
  | ToolResultEvent
  | ToolConfirmationRequiredEvent
  | ToolConfirmationResultEvent
  // DevTools events
  | CompiledEvent
  | ModelRequestEvent
  | ProviderRequestEvent
  | ModelResponseEvent
  // Context utilization
  | ContextUpdateEvent
  // Fork/Spawn orchestration
  | ForkStartEvent
  | ForkEndEvent
  | SpawnStartEvent
  | SpawnEndEvent
  // Errors
  | EngineErrorEvent;

// ============================================================================
// Result Event
// ============================================================================

/**
 * Final execution result.
 */
export type ResultStreamEvent = {
  type: "result";
  executionId?: string;
  result: SessionResultPayload;
} & StreamEventBase;

// ============================================================================
// Combined Event Type
// ============================================================================

/**
 * StreamEvent - Combined union of model, orchestration, and result events.
 *
 * This is what engine.stream() yields.
 */
export type StreamEvent = ModelStreamEvent | OrchestrationStreamEvent | ResultStreamEvent;

// ============================================================================
// Event Type Guards
// ============================================================================

/**
 * Check if event is a ModelStreamEvent (model output)
 */
export function isModelStreamEvent(event: StreamEvent): event is ModelStreamEvent {
  return [
    "content_start",
    "content_delta",
    "content_end",
    "content",
    "reasoning_start",
    "reasoning_delta",
    "reasoning_end",
    "reasoning",
    "message_start",
    "message_end",
    "message",
    "tool_call_start",
    "tool_call_delta",
    "tool_call_end",
    "tool_call",
    "usage",
    "error",
  ].includes(event.type);
}

/**
 * Check if event is an OrchestrationStreamEvent (orchestration)
 */
export function isOrchestrationStreamEvent(event: StreamEvent): event is OrchestrationStreamEvent {
  return [
    "execution_start",
    "execution_end",
    "execution",
    "tick_start",
    "tick_end",
    "tick",
    "tool_result",
    "tool_confirmation_required",
    "tool_confirmation_result",
    "compiled",
    "model_request",
    "model_response",
    "context_update",
    "fork_start",
    "fork_end",
    "spawn_start",
    "spawn_end",
    "engine_error",
  ].includes(event.type);
}

/**
 * Check if event is a Fork event
 */
export function isForkEvent(event: StreamEvent): event is ForkStartEvent | ForkEndEvent {
  return ["fork_start", "fork_end"].includes(event.type);
}

/**
 * Check if event is a Spawn event
 */
export function isSpawnEvent(event: StreamEvent): event is SpawnStartEvent | SpawnEndEvent {
  return ["spawn_start", "spawn_end"].includes(event.type);
}

/**
 * Check if event is a delta event (for streaming UI)
 */
export function isDeltaEvent(
  event: StreamEvent,
): event is ContentDeltaEvent | ReasoningDeltaEvent | ToolCallDeltaEvent {
  return ["content_delta", "reasoning_delta", "tool_call_delta"].includes(event.type);
}

/**
 * Check if event is a final/complete event
 */
export function isFinalEvent(
  event: StreamEvent,
): event is
  | ContentEvent
  | ReasoningEvent
  | MessageEvent
  | ToolCallEvent
  | TickEvent
  | ExecutionEvent
  | ResultStreamEvent {
  return ["content", "reasoning", "message", "tool_call", "tick", "execution", "result"].includes(
    event.type,
  );
}
